# 数据结构



### 二叉搜索树

最小节点：最左节点（不管是否有右孩子）

最大节点：最右节点（不管是否有左孩子）

> 假定二叉树根节点的父节点为null

```
/*-----------*\
|    null     |
|      |      |
|    root     |
|    /  \     |
|   ......    |
\*-----------*/
```



#### 查找

循环实现

```c++
NodePtr find(NodePtr root, key_type key)
{
  while(root != nullptr && root->key != key)
  {
    if(key < root->key) root = root->left;
    else 								root = root->right;
  }
  return root;
}
```

#### 插入

允许重复，循环实现

```c++
void insert_multi(NodePtr& root,NodePtr z)
{
  NodePtr y = nullptr, x = root;
  while(x != nullptr){
    y = x;
    if(z->key < x->key) // 小于插左，大于等于插右
      x = x->left;
    else
      x = x->right;
  }
  // y 指向插入位置父节点
  if(y == nullptr) // 空树
    root = z;
  else if(z->key < y->key)
    y->left = z;
  else
    y->right = z;
}
```

不允许重复，循环实现

> 相同值，在高处的值对应左边，在低处的值对应右边

```c++
// 先插入再删除版本
void insert_unique(NodePtr& root, NodePtr z)
{
	insert_multi(root, z);
  // 找待插入节点的前驱，因为大于等于插右，所以新插入的重复节点在后（右）
  NodePtr pre = findPre(root, z);
  if(pre->key == z->key) delet(root, z);
}

// 直接插入版本
void insert_unique(NodePtr& root, NodePtr z)
{
  NodePtr y = nullptr, x = root;
  bool add_to_left = true;
  while(x != nullptr){
    y = x;
    add_to_left = key < y->key ? 1 : 0;
    x = add_to_left ? x->left : x->right;
  }
  NodePtr pre = y; // 前驱
  if(add_to_left){
    if(y == nullptr || y == Min) { y->left = z; return; }
    pre = findPre(y); // x前驱为y的前驱
  }
  if(pre->key == key) return;
  if(add_to_left) y->left  = z;
  else 						y->right = z;
}
```



#### 前驱/后继

<img src="https://i.loli.net/2020/04/13/Q4BLCVTNwFY5buJ.png" alt="s" style="zoom:50%;" />

#### 寻找前驱

> 寻找小于此节点的最大值

If 节点存在左子树，则为左子树中最大值

​						  else 则为祖先中第一个左父亲

如果没有找到左子树或祖先中的左父亲，则该节点为最左节点（最小节点），无前驱

```c++
NodePtr findPre(NodePtr x)
{
  if(x->left != nullptr) return findMax(x->left);
  p = x->parent;
  while(p != nullptr && x == p->left) { x = p; p = x->parent; }
  if(p == nullptr) return nullptr;
  else 						 return p;
}
```

#### 寻找后继

> 寻找大于此节点的最小值

if 节点存在右子树，则为右子树中最小值

​						  else 则为祖先中第一个右父亲

如果没有找到右子树或祖先中的右父亲，则该节点为最右节点（最大节点），无后继

```c++
NodePtr findSuc(NodePtr x)
{
  if(x->right != nullptr) return findMin(x->right);
  p = x->parent;
  while(p != nullptr && x == p->right) { x = p; p = x->parent; }
  if(p == nullptr) return nullptr;
  else						 return p;
}
```

### LCA

#### 二叉搜索树

```c++
NodePtr LCA(NodePtr t, NodePtr u, NodePtr v){
  if(t->value < u->value && t->value < v->value) // 均在右子树	
    return LCA(t->right, u, v);
  else if(t->value > u->value && t->value > v->value) // 均在左子树
    return LCA(t->left, u, v);
  else return NodePtr;
}
```

