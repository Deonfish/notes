# 图论算法

### Dijkstra+堆优化

```c++
struct HeapNode{
    HeapNode(int _u, int _d) : u(_u), d(_d){ }
    int u, d;
    bool operator < (const HeapNode &v) const { return d > v.d; }
}
struct Edge{
    int to, len;
}

vector<Edge> adj[maxn];
int d[maxn];
bool vis[maxn];
priority_queue<HeapNode> q; // 优先队列对已开放顶点（已优化）进行排序，每次队首一定是最优解

void dijkstra(int s){
    fill(d, d+maxn, 1e9);
    d[s] = 0;
    q.push(HeapNode(s, 0));
    while(!q.empty()){
        HeapNode f = q.top(); q.pop();
        int u = f.u;
        if(vis[u]) continue; // 可重复入队，最优解已经被记录
        vis[u] = true;
        for(itn i = 0; i < adj[u].size(); i++){
            Edge e = adj[u][i];
            if(d[e.to] > d[u] + e.len){
                d[e.to] = d[u] + e.len;
                q.push(HeapNode(e.to, d[e.to]));
            }
        }
    }
}
```



### Kruskal

伪代码

```c++
vector<Edge> edges;

void Kruskal(){
    sort(edges);
    for(遍历edges的每个e){
        if(e的两端u，v不在同一集合中) Union(u, v);
    }
}
```

实现

```c++
struct Edge{
    int from, to, len;
    bool operator < (const Edge &e) const { return len < e.len; }
};

vector<Edge> edges;
int father[maxn];

int findFather(int x){
    if(father[x] != x) father[x] = findFather(father[x]);
    return x;
}
void Union(int a, int b){
    int fa = findFather(a), fb = findFather(b);
    if(fa != fb) father[fa] = fb;
}

void kruskal(){
    for(int i = 1; i <= n; i++) father[i] = i; //初始化并查集
    sort(edges.begin(), edges.end());
    for(int i = 0; i < edges.size(); i++){
        Edge e = edges[i];
        if(findFather(e.from) != findFather(e.to))
            Union(e.from, e.to);
    }
}
```

### Bellman_Ford

伪代码

```c++
bool BellmanFord(int s){
	d[s] = 0;
    for(v-1){//进行v-1次遍历
        for(each edge u -> v) //遍历每条边
            if(d[u] + length[u->v] < d[v]) //可以以u节点优化
                d[v] = d[u] + length[u-v]; //优化
    }
    for(each u->v)
        if(d[u] + length[u-v] < d[v]) //如果仍存在可优化边
            return false; //图中有负环
}
```

### SPFA

> shortest-path-faster-algorithm

*只有某个顶点`u`的`d[u]`被改变时，他的相邻点`v`的`d[v]`才有可能改变*

伪代码

```c++
//无负环图
void SPFA(int s){
    queue<int> q;
		q.push(s);
    while(!q.empty()){
        取出队首元素u; //被改变的u
        for(each edge u->v){
            if(d[u] + dis < d[v]){
                d[v] = d[u] + dis;
                if(v不在队中) v入队;
            }
        }
    }
}

```

实现

```c++
//无负环图
vector<Edge> adj[maxn];
int n, d[maxn];
bool inq[maxn];

void SPFA(int s){
    fill(d, d+maxn, 1e9);
    queue<int> q;
    q.push(s);
    inq[s] = true;
    d[s] = 0;
    while(!q.empty()){
        int u = q.front(); q.pop();
        inq[u] = false; //可能多次入队
        for(int i = 0; i < adj[u].size(); i++){
            Edge e = adj[u][i];
            if(d[e.to] > d[e.to] + e.len){
                d[e.to] = d[e.to] + len;
                if(!inq[e.to]) { q.push(e.to); inq[e.to] = true; }
            }
        }
    }
}
```

### Floyd

伪代码

```c++
初始化dist INF， dist[i][i] = 0, dist[i][j] = e(i->j);
for(顶点k)
	枚举所有dist[i][k], dist[k][j];
		if(dist[i][k] + dist[k][j] < dist[i][j])
            dist[i][j] = dist[i][k] + dist[k][j];
```

c++

```c++
void floyd(){
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                if(dist[i][k] != INF && dist[j][k] != INF && dist[i][k] + dist[k][i] < dist[i][j])
                	dist[i][j] = dist[i][k] + dist[k][j];
```

### Tarjan

```c++
const int maxn;
vector<int> adj[maxn];
stack<int> st;
int dfn[maxn], low[maxn];
bool ins[maxn];
int index = 0;

void tarjan(int u){
	dfn[u] = low[u] = ++index;
	st.push(u);
	ins[u] = true;
	for(int v : adj[u]){
		if(!dfn[v]){
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if(ins[v]) low[u] = min(low[u], dfn[v]);
	}
	if(dfn[u] == low[u]){
		int s;
		do{
			s = st.top(); st.pop();
			ins[s] = false;
			//
		}while(s != u);
	}
}
```


