# 小算法

### 素数

从2到根号x查询是否可以整除x，都不能则是素数

```c++
bool isPrime(int x){
  int sq = sqrt(x);
  if(x == 1) return false;
  for(int i = 2; i <= sq; ++i)
    if(x % i == 0) return false;
  return true;
}
```

### 辗转相除法求最大公约数

定理：gcb(a,b) = gcb(a,ka+b),其中a、b、k都为自然数.………………

```c++
int gcb(int a, int b){
  if(b > a) swap(a, b);
  if(b == 0) return a;
  return gcb(b, a%b);
}
```

### 向上取整

L/m向上取整

```c++
int res = (L-1)/m + 1;
```

### 分割子串

```c++
// 寻找由','分割的字符串
for(int i = 0, j = 0; j < s.size(); ++j, i = j) // 跳过 ','
{
	while(j < s.size() && s[j] != ',') ++j; // 此时j指向末尾或 ','
  string substr = s.substr(i, j-i);
  // ...
}
```

#### 映射输入

用于图或树题，所给节点不是标准 0~n-1 或 1~n，进行映射操作，所有数据结构存储映射以后的index，只有在输出时进行转换

（可能有部分和输入相关的数组存储映射前的input以对输入进行判断）

> 注意检查该用没用to_index的地方！

```c++
int num = 0;
unordered_map<int, int> to_index, to_input;
vector<int> vec; // 存储映射以后的index
vector<int> ans; // 同样存储映射以后的ans

输入：
for(auto &x : vec) 
{ cin >> x; to_input[num] = x; x = to_index[x] = num++; }

// 算法中全部使用映射后的index

输出：
for(auto x : ans) cout << to_input[x];
```

