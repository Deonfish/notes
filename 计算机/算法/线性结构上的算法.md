## 排序

**选择排序**：

每次选择最小元素和第一元素交换

- 排已序数组和无序数组时间一样，数据移动最少

复杂度：O(n^2)

**插入排序**：

每次选择一个元素插入已序部分数组的合适位置（逆序则往前换）

- 排已序数组非常最快，适合小规模数组

复杂度：O(n^2)

**希尔排序**：

...有序 -> 13-有序 -> 4-有序 -> 1-有序（每次插入排序）

h-有序之后数组是部分有序，此时比较适合插入排序，只要递增序列选择合理

- 大数组适用

复杂度：O(n^3/2)



### 归并排序

递归<u>归并</u>（将两个已序数组合成为已序数组）

- 大小数组均适用，是一种渐进最优的算法（最坏情况下仍为nlgn），
  主要缺点是需求额外空间n

改进：小规模数组使用插入排序可加速10%~15%

时间复杂度：nlgn

空间复杂度：n



### 快速排序

递归调用<u>切分</u>（选择切分元素k，左右分别小于等于k、大于等于k），当子数组分别有序时数组有序

```python
partition(list):
	数组第一个元素为切分元素k
  while(True):
    找左边>k元素
    找右边<k元素
    若(i>=j) break
    交换两个元素
  把k放入正确位置
```

问题：对基本有序数组性能很差，因为每次切分很不平衡（ 降为O(n^2) ）

改进：

- 对于小数组切换到插入排序
- 三取样切分：取数组前三个元素的中位数进行切分

问题：对于大量重复元素比较差

改进：

三向切分快速排序：将数组分为三部分（小于、等于、大于k）

复杂度：nlgn



### 堆

堆：大根堆/小根堆，根节点元素大于（小于）等于所有孩子元素

二叉堆是完全二叉树，用一个数组存储

插入：插入到数组最后，上浮到合适位置

删除：交换根节点和数组最后节点，删除该节点，将根节点下沉到合适位置

复杂度：

- 查找：O(1)

- 插入：lgn
- 删除：lgn
- 排序：时间：nlgn，空间：n



### 桶排序

被排序标准可以hash

例：对全校900个学生的考试成绩排序，成绩为0～100（可hash）
分配一个hashtable[101]，遍历学生成绩填入hashtable

时间复杂度：O(n)

空间复杂度：O(k)

## hash

碰撞与`hash function`和`hashTable大小均有关`

### 散列函数

最常用是除留余数法，即 hash = k % M，使其分布在 0~M-1

### 拉链法

每个散列值对应一个链表，查找时遍历链表，插入、删除操作均为操作链表

### 开放探测

#### 线性探测

碰撞则向后插入/查找，

删除：

- 用一个delet标记删除，查找时遇到delet向后查找，插入时遇到delet可以插入
- 删除元素，移动后面需要移动的元素

#### 二次探测

按 `（hashkey + i*i）% len`探测

存在插入失败的情况：

若枚举增量直至`i == hashtable.size`仍无法插入则插入失败，

因为往后的插入和第一轮插入相同

```
   (key + (size+i)^2)%size
 = key%size + i^2 % size
 = (key + i^2) % size
```

查找时也是按探测顺序查找

## 字符串

### KMP算法

匹配子串

前缀/后缀集合：所有前缀/后缀的集合（不包括自身）

next数组：

- 在子串的j位置不匹配时应该检查的子串的下一个位置
- 长度为j的子串前缀集合与后缀集合交集中最长元素的长度（该元素的下一个位置）

```c++
int KMP(char * t, char * p) 
{
	int i = 0; 
	int j = 0;

	while (i < strlen(t) && j < strlen(p))
	{
		if (j == -1 || t[i] == p[j]) 
		{
			i++;
           		j++;
		}
	 	else 
           		j = next[j];
    	}

    if (j == strlen(p))
       return i - j;
    else 
       return -1;
}
```

```c++
void getNext(char * p, int * next)
{
	next[0] = -1;
	int i = 0, j = -1;

	while (i < strlen(p))
	{
		if (j == -1 || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j;
		}	
		else
			j = next[j];
	}
}
```

